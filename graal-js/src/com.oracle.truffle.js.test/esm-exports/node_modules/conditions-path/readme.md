# Conditional exports

[Node docs](https://nodejs.org/api/packages.html#conditional-exports)

```json
"exports": {
  ".": {
    "import": "./dist/esm/index.js",
    "require": "./dist/commonjs/index.js",
    "types": "./dist/esm/index.d.ts"
  }
}
```

## How this works

1. **Export path `"."`**

   * Represents the **package root** (`import 'package'` or
     `require('package')`).

2. **Conditional exports at the first level inside `"."`**

   * `"import"` → Node uses this file for **ESM `import`** statements.
   * `"require"` → Node uses this file for **CommonJS `require()`**.

3. **Other fields inside the same object**

   * `"types"` → TypeScript declaration file; Node ignores this, it’s only for
     tooling.
   * `"default"` is no longer needed because Node picks the condition directly.

## Key points

* Node picks the **first-level key** (`import` or `require`) to resolve the
  module.
* The `"types"` field is metadata for TypeScript, ignored by Node.
* This flattened structure removes the inner `default`/`types` objects while
  keeping Node resolution and TypeScript typing intact.

**Visual hierarchy:**

```
"." (package root)
 ├─ "import"  → JS entry for ESM
 ├─ "require" → JS entry for CJS
 └─ "types"   → TS declaration (ignored by Node)
```

Node resolves the module using the **appropriate condition key**, so a nested
`"default"` object is unnecessary.
