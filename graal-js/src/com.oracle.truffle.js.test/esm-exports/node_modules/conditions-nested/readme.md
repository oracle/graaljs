# Nested conditions

[Node docs](https://nodejs.org/api/packages.html#nested-conditions)

```json
"exports": {
  ".": {
    "import": {
      "types": "./dist/esm/index.d.ts",
      "default": "./dist/esm/index.js"
    },
    "require": {
      "types": "./dist/commonjs/index.d.ts",
      "default": "./dist/commonjs/index.js"
    }
  }
}
```

Here’s what’s actually happening:

1. `"."` is the **export path for the main entry** (`import 'package'` or
   `require('package')`).

2. Inside `"."`, Node uses **conditional exports**:

   * `"import"` → Node picks this object **if the consumer does an ESM
     `import`**.
   * `"require"` → Node picks this object **if the consumer does a CommonJS
     `require()`**.

3. The objects under `"import"` and `"require"` are **not Node conditions
   themselves**, they’re **sub-fields used by the package/tooling**:

   * `"default"` → the JS file to load for that system
   * `"types"` → the TypeScript declarations

So the reason for this **two-level structure** is:

* Node only cares about the first-level `"import"`/`"require"` keys to pick the
  module system.
* The inner `"default"`/`"types"` is **package-specific metadata** (TypeScript
  support, or multiple entry points for tooling).

It’s perfectly valid, but **Node itself ignores `"types"`** — it just picks
`"default"` for the resolution.

Essentially:

```
"." (export path)
 ├─ "import" → chosen if import()
 │    ├─ "default" → actual JS
 │    └─ "types"   → TS definitions
 └─ "require" → chosen if require()
      ├─ "default" → actual JS
      └─ "types"   → TS definitions
```

Node picks the outer key (`import` vs `require`), then the package uses
`"default"`/`"types"` inside for its own purposes.
